def help_file() {
    log.info """
    #######################################################################################
    ######################### DOWNLOAD FILES FROM BPA DATA PORTAL #########################
    #######################################################################################

        options:

        --dry_run
                If set, a list of the samples that would be downloaded will be returned,
                and files will not actually be downloaded.
                Set this to avoid accidentally downloading Glacier files.
                Default is 'true'  ## set to false after testing is complete ##

        --pacbio_data
                Does the sample_id have PacBio HiFi data files to download, or not?
                Default is 'false'

        --hic_data
                Does the sample_id have HiC data files to download, or not?
                Default is 'false'

        --ont_data
                Does the sample_id have Oxford Nanopore data files to download, or not?
                Default is 'false'

        input:

        --yaml <PATH/TO/YAML/FILE>
                Path to the .yaml file generated by the data mapper query

        --bpa_api_token BPA_API_TOKEN
                API token for BioPlatforms Australia, enables downloading of datasets
                that may not be publically accessible. Token can be created by logging 
                into https://data.bioplatforms.com/, then going to
                https://data.bioplatforms.com/user/<username>/api-tokens, and clicking 
                'Create API Token'. 

        output:
        
        --outdir <PATH/TO/OUTPUT/DIRECTORY>
                File path to where downloaded files should be stored
                Default is './results/raw_reads'

                Each file type will automatically be given its own subdirectory inside 
                this one, e.g.:
                    pacbio reads:   './results/raw_reads/hifi/'
                    nanopore reads: './results/raw_reads/ont/'
                    hi-c reads:     './results/raw_reads/hic/'

    #######################################################################################
    """.stripIndent()
}


// print help file if requested
if ( params.remove('help') ) {
    help_file()
    exit 0
}

// check no unexpected parameters were specified
allowed_params = [
    // pipeline inputs
    "yaml",
    "dry_run",
    "bpa_api_token",
    "outdir",
    "pacbio_data",
    "hic_data",
    "ont_data",

    // Pawsey options
    "max_cpus",
    "max_memory"
]

// check for any unknown parameters
params.each { entry ->
    if ( !allowed_params.contains(entry.key) ) {
        println("The parameter <${entry.key}> is not known");
        exit 0;
    }
}

// check required parameters are specified; throw error if not
if ( !params.yaml ) { error(
    """
    ERROR: No yaml file provided: \'--yaml\'
    """
)}

// some files can be downloaded without a token, but better to have one
// amend in future if necessary
if ( !params.bpa_api_token ) { error(
    """
    ERROR: No BPA API token provided: \'--bpa_api_token\'
    """
)}

// if no data types are specified, throw error
if ( !params.pacbio_data && !params.hic_data && !params.ont_data ) { error(
    """
    ERROR: \'--pacbio_data\', \'--hic_data\', and \'--ont_data\' flags are all turned off.
    No data files will be downloaded. Please set at least one data flag.
    """
)}

// pull in scripts for relevant processes
include { DOWNLOAD_FILE as DOWNLOAD_FILE_PACBIO } from './modules/download_file.nf'
include { DOWNLOAD_FILE as DOWNLOAD_FILE_HIC } from './modules/download_file.nf'
include { DOWNLOAD_FILE as DOWNLOAD_FILE_ONT } from './modules/download_file.nf'

// pull the snakeyaml add-on to process the .yaml file
def readYAML(yamlfile) {
    return new org.yaml.snakeyaml.Yaml().load(yamlfile.text)
}

// actually run the workflow
workflow {

    // #############################
    // ### read in the yaml file ###
    // #############################

    def yaml_data = readYAML(file(params.yaml))

    // ############################
    // ### process pacbio reads ###
    // ############################

    if ( params.pacbio_data ) {

        // pull out the pacbio section of the config
        pacbio_samples = yaml_data.reads.PACBIO_SMRT

        // check it exists; format data for downloading
        if ( !pacbio_samples ) { error(
            """
            \'--pacbio_data\' is set as true, but no PacBio samples were listed in the config .yaml
            Check the .yaml file or turn off \'--pacbio_data\' flag
            """
            ) 
        } else {
            pacbio_samples_reformatted = pacbio_samples
                .collectMany { pkg, pkgData ->
                    pkgData.collect { file ->
                        [
                            package: pkg,
                            file_name: file.name,
                            format: file.format,
                            url: file.url,
                            md5sum: file.md5sum,
                            lane: [],
                            read: []
                        ]

                    }
                }
            
            pacbio_samples_ch = Channel.from(pacbio_samples_reformatted)

        }

        // make sure we're not downloading anything accidentally
        if ( params.dry_run ) {
            pacbio_samples_ch.view()
        } else {
            DOWNLOAD_FILE_PACBIO(pacbio_samples_ch, 'hifi')
        }
    }


    // #########################
    // ### process hic reads ###
    // #########################

    if ( params.hic_data ) {

        // pull out the hi-c section of the config
        def hic_samples = yaml_data.reads.'Hi-C'

        // check it exists; format data for downloading
        if ( !hic_samples ) { error(
            """
            \'--hic_data\' is flagged, but no Hi-C samples were listed in the config .yaml
            Check the .yaml file or turn off \'--hic_data\' flag
            """)

        } else {

            hic_samples_reformatted = hic_samples
                .collectMany { pkg, pkgData ->
                        pkgData.collectMany {read, files ->
                            files.collect { file ->
                                [
                                    package: pkg,
                                    file_name: file.name,
                                    format: file.format,
                                    url: file.url,
                                    md5sum: file.md5sum,
                                    lane: file.lane_number,
                                    read: read
                                ]
                            }
                        }
                    }

            hic_samples_ch = Channel.from(hic_samples_reformatted)
        }

        // make sure we're not downloading anything accidentally
        if ( params.dry_run ) {
            hic_samples_ch.view()
        } else {
            DOWNLOAD_FILE_HIC(hic_samples_ch, 'hic')
        }
    }


    // // #############################
    // // ### downloading ont reads ###
    // // #############################

    // // NOTE: there is currently no nanopore data in the data mapper output

    // if ( params.ont_data ) {
    
    //     if ( !params.use_samplesheet ) {
    //         // may also need to filter on archive_type = fastq_pass to avoid getting failed reads or pod5 output
    //         // keep an eye on data mapper output to see what happens here
    //         ont_samples = all_samples
    //             .filter { sample -> sample.organism_grouping_key == "${params.sample_id}" }
    //             .filter { sample -> sample.library_strategy == "ONT" }
    //             .map { sample -> [sample.organism_grouping_key, sample.file_name, sample.url, sample.file_checksum] }

    //     } else {

    //             ont_samples = all_samples
    //             .filter { sample -> sample.sample_id == "${params.sample_id}" }
    //             .filter { sample -> sample.data_type == "ONT" }
    //             .map {sample -> [sample.sample_id, sample.file_name, sample.url, sample.file_checksum] }

    //     }

    //     ont_samples.ifEmpty { error(
    //         """
    //         \'--ont_data\' is flagged, but no ONT samples corresponding to sample id 
    //         \"${params.sample_id}\" could be found.
    //         Check sample information or turn off \'--ont_data\' flag
    //         """) }\

        // make sure we're not downloading anything accidentally
        // if ( params.dry_run ) {
        //     ont_samples_ch.view()
        // } else {
        //     DOWNLOAD_FILE_ONT(ont_samples_ch, 'ont')
        // }
    // }
}